
- 요약 : <font color="#00b0f0">쿼리 최적화</font>
	- 쿼리에 처리에 대한 효율적인 전략을 찾는 과정
	- 관계형 표현식의 변환
		- 동등성 규칙
		- 동등한 표현식의 열거
	- 표현식 결과의 통계량 추정
		- 데이터베이스 시스템 카탈로그
		- Select, Join 및 기타 작업의 크기 추정
	- 평가 계획 선택
		- 비용 기반 옵티마이저
		- 최적화에 대한 휴리스틱
	- 재료화된 뷰
		- 점진적 뷰 유지보수
		- 뷰 및 인덱스 선택

- **쿼리 최적화**
	- <font color="#00b0f0">주어진 쿼리를 가장 효율적으로 처리하기 위한 전략을 찾는 과정</font>
	- <font color="#00b0f0">Relation Algebra Level</font>
		- 주어진 표현식과 <font color="#00b0f0">동등한 표현식</font> 생성 후 가장 비용이 적은 계획을 선택
	- <font color="#00b0f0">Detailed Strategy</font>
		- 쿼리의 처리 위해 사용할 <font color="#00b0f0">알고리즘, 특정 인덱스</font> 선택
	- **평가 계획**
		- 각 작업에 사용되는 정확한 알고리즘과 작업의 실행이 어떻게 조정되는지 정의
	- **비용 기반 쿼리 최적화의 과정**
		1. <font color="#00b0f0">동등성 규칙</font>을 사용해 논리적으로 동등한 표현식 생성
		2. 대체 쿼리 계획을 얻기 위해 예상 비용에 따라 표현식에 주석 추가
		3. <font color="#00b0f0">추정 비용</font>에 기반하여 가장 저렴한 계획 선택

- 관계식의 변환
	- **동등한** 표현식으로 변환 하는 것
		- 이는 모든 DBMS에서 동일한 튜플 집합을 생성한다는 것을 의미
	- **등가규칙** 
		- 두 형태의 표현식이 동등한 것
		- 첫번째 형태의 표현식을 두번째 형태로 대체, Vice Versa 
	- 최소 동등성 규칙 집합
		- 동등성 규칙 집합이 **최소**일 경우, 다른 규칙의 조합에서 어떤 규칙도 유도될 수 없음
		- 비최소 동등성 규칙 집합을 이용하면 표현식 생성 방법 수 증가
		- 쿼리 옵티마이저는 <font color="#00b0f0">최소 동등성 규칙 집합 사용</font>
		- <u>선택 연산을 최대한 빨리 수행하여</u> <font color="#00b0f0">조인할 관계의 크기를 줄이는 것이 중요</font>
	- 조인 순서
		- 조인 작업의 순서를 잘 선택하는 것은 임시 결과의 크기를 줄이는데 중요
		- 예를 들어, (r1 r2) r3 = r1 (r2 r3) 일때 r1 r2가 작고 r2 r3이 매우 크다면, 우리는 (r1 r2) r3을 선택
		- 이렇게 <font color="#00b0f0">더 작은 임시 관계</font>를 계산하고 저장 가능
	- 동등한 표현의 열거
		- 쿼리 최적화기는 주어진 표현식과 동등한 표현식을 <font color="#00b0f0">체계적으로</font> 생성하기 위해 동등성 규칙을 사용
		- 동등한 표현 생성 위해 다음을 반복
			- 지금까지 찾은 모든 동등한 표현의 모든 하위 표현식에 모든 적용 가능한 동등성 규칙을 적용
			- 새롭게 생성된 표현식을 동등한 표현의 집합에 추가
			- 이는 매우 많은 시간 소요 
	- 변환 기반 최적화 구현
		- <font color="#00b0f0">공통된 하위 표현식 공유</font>로 공간 요구 사항 감소 가능
		- <font color="#00b0f0">동적 프로그래밍</font>을 통해 시간 요구 사항 감소 가능

- 비용 추정 전략
	- 비용 추정을 위한 통계 정보
		- r이라는 관계에 있는 튜플의 수 **(nr)**
		- r의 튜플을 포함하는 블록의 수 **(br)**
		- r의 튜플의 크기 **(lr)**
		- r의 블로킹 팩터 **(fr)** - 즉, r의 튜플 중 하나의 블록에 들어갈 수 있는 튜플의 수
		- A 속성에 나타나는 r의 고유 값의 수 **(V(A, r))** 
		  → 즉, ∏A(r)의 크기와 동일함
		- 만약 r의 튜플이 물리적으로 파일에 함께 저장된다면
		  ![[Pasted image 20231207212624.png|100]]<font color="#00b0f0">→Database-System Catalog</font>
		  예) n<sub>student</sub>=5000, f<sub>student</sub>=50 → b<sub>student</sub>= 00
	- 비용 추정을 위한 **근사 접근 방식**
			- 정확한 통계를 유지하려면 관계가 수정될 때 마다 통계도 업데이트 해야함
			- 대부분의 시스템은 모든 수정마다 통계를 업데이트하지 않고, 시스템 부하가 적은 시기에 통계를 업데이트
			- 따라서, 쿼리 처리 전략을 선택하기 위해 사용되는 통계는 완전히 정확하지 않을 수 있음
			- 그러나, 통계 업데이트 간격에서 업데이트 사이에 너무 많은 수정이 발생하지 않는다면, 통계는 충분히 정확할 것
	- 히스토그램
		- 실제 세계의 최적화 도구에서 비용 추정을 개선하기 위해 추가적인 통계 정보를 유지
		- 대부분의 데이터 베이스는 각 속성값의 분포를 <font color="#00b0f0">히스토그램</font>으로 저장
		- 속성에 대한 히스토그램이 있다면, 보다 정확한 추정치를 얻을 수 있음
	- 선택도
		- 선택 조건의 <font color="#00b0f0">선택도</font>는 관계 r이 튜플의 조건을 만족 시킬 확률
		- r에서 만족하는 튜플의 수가 S<sub>i</sub>라면, 조건의 선택도는 S<sub>i</sub> / N<sub>i</sub> 이다
			- 논리곱![[Pasted image 20231208024524.png]]
			- 논리합![[Pasted image 20231208024543.png]]
			- 부정![[Pasted image 20231208024550.png|120]]
	- 조인 크기 추정
		- R ^ S 가 R의 키인 경우, <u>S의 튜플은 최대 한개의 R 튜플과만 결합 가능</u>
		  → R join S 의 튜플 수는 S에 있는 튜플보다 많을 수 없음
		- R ^ S 가 R을 참조하는 S의 외래키인 경우,<u> R join S의 튜플 수는 정확히 S의 튜플 수와 일치함</u> **(정말?)**
		- R ^ S 가 R 또는 S의 키가 아닌 경우, R join S 의 크기는 ![[Pasted image 20231208030350.png]]로 추정됨. 그 역이 참이라면, 추정치는 아마도![[Pasted image 20231208030421.png]]
		  히스토그램이 정확도를 높여줄 수 있음

- 평가 계획 선택
	- 평가 계획의 선택 
		- <font color="#00b0f0">평가 계획</font>은 각 작업에 대해 사용해야 하는 정확한 알고리즘과 작업의 실행을 어떻게 조정해야 하는지를 정의
			- 비용 추정을 위한 통계 및 제시된 다양한 알고리즘과 평가 방법의 비용 추정을 사용
		- <font color="#00b0f0">비용 기반 옵티마이저</font>는 주어진 쿼리와 동등한 모든 쿼리 평가 계획 공간을 탐색하고, 예쌍 비용이 가장 적은 계획을 선택
			- 복잡한 쿼리의 경우 모든 가능한 계획 공간을 탐색하는 것은 너무 많은 비용이 들 수 있으므로 대부분의 옵티마이저는 쿼리 최적화 비용을 줄이기 위한 <font color="#00b0f0">휴리스틱</font>을 포함
			- 이는 최적 계획을 찾지 못할 가능성이 있지만, 쿼리 최적화 비용을 줄일 수 있음
	- 비용 기반 조인 순서 선택
		- n개의 테이블이 있을 때 (2(n-1))!(n-1)!만큼의 다른 조인 순서가 있을 수 있음 
		  → <font color="#00b0f0">n = 3 일때 12개의 조인 순서</font>
		- <font color="#00b0f0">동적 프로그래밍</font>을 사용해 {r1,r2 … ,rn}의 모든 부분 집합에 대한 최소 비용 조인 순서를 한번만 계산하고 저장할 수 있음
	- 동적 프로그래밍 
		- 중복 계산을 없애기 위해 <font color="#00b0f0">Memorization</font> 활용
	```C++
	int memo[100] = {0};
	int fibo(int n){
		if( n <= 1) return n;
		else{
		**if (memo[n] > 0) return memo[n];**
			memo[n] = fibo(n-1) + fibo(n-2)
			return memo[n];
		}
	}
	```
	- 휴리스틱 최적화
		- 비용 기반 최적화는 동적 프로그래밍으로도 비용이 많이 드는 작업
		- 시스템은 비용 기반 방식으로 선택해야 할 선택지의 수를 줄이기 위해 <font color="#00b0f0">휴리스틱</font> 사용 가능
		- 휴리스틱 최적화는 일련의 규칙을 사용해 쿼리 트리를 변형해 실행 성능을 향상시킴
			- 초기 Select 작업을 수행해 튜플의 수 줄임
			- 초기 Projection 작업을 수행해 속성의 수 줄임
			- 가장 제한적인 선택 및 조인 작업 (즉 , 결과의 크기가 가장 작은 작업)을 다른 유사한 작업보다 먼저 수행
			- 일부 시스템은 휴리스틱만 사용, 다른 시스템은 휴리스틱과 부분적인 비용 기반 최적화를 결합하여 사용
	- 중첩(nested) 쿼리 최적화
		- 중첩 쿼리를 조인으로 사용하는 쿼리로 대체하는 과정을 <font color="#00b0f0">Decorrelation</font> 이라 함![[Pasted image 20231208191526.png]]
		- 복잡한 중첩 서브쿼리의 최적화는 어려운 작업이며, 많은 옵티마이저는 제한된 Decorrelation 만 수행
		- 가능하다면 복잡한 중첩 서브쿼리 사용을 지양
	- 쿼리 옵티마이저의 구조
		- 쿼리 옵티마이저는 휴리스틱을 사용하여 비용 기반으로 쿼리를 최적화 → 상당한 오버헤드
		- 그러나 <u>비싼 쿼리</u>에 대해서는 가치 있음
		- 최적화된 쿼리 계획은 쿼리가 실행될 때 마다 사용될 수 있으므로, 정기적으로 실행되는 애플리케이션에서는 실제로 절약 효과가 증폭됨
		- 그러므로 옵티마이저는 저렴한 쿼리에 대해서는 간단한 휴리스틱 사용, 비싼 쿼리에 대해서는 완전한 열거 수행
	- 비용 기반 최적화와 동등 규칙
		- **물리적 동등 규칙**을 사용해 논리적 쿼리 계획을 물리적 쿼리 계획으로 변환 가능
			- 이는 각 연산에 대해 어떤 알고리즘을 사용할지 지정
			- 조인 연산은 해시조인, 중첩 루프 조인 사용 가능
		- 효율적인 옵티마이저는 동등 규칙에 기반한 효율적인 기법에 의존
			- 이를 위해 표현식의 공간 효율적인 표현이 필요
			- 또한 하위 표현식의 중복 파생을 감지하는 효율적인 기술이 필요
			- 메모리제이션을 기반으로 한 동적 프로그래밍 형태도 필요
				- 이는 최적화가 처음 호출될 때 하위 표현식에 대한 최상의 계획을 저장, 동일한 하위 표현식에 대한 반복적인 최적화 호출에서 재사용
			- 또한 모든 계획을 생성하지 않고 비용 기반 가지치기 기법을 사용해 최적화를 수행
	- 쿼리 평가 계획 보는 방법
		- 대부분의 데이터베이스는 <font color="#00b0f0">explain</font><쿼리>를 지원
			- 이를 통해 쿼리 옵티마이저가 선택한 계획가 비용 추정치 계산 가능

- [[materialized view]] 
	- **Materialized view**
		- 계산되고 저장된 내용을 가진 뷰
		```sql
		create view dept_total_sal as
		select dept_name, sum(salary)
		from instructor
		group by dept_name
		```
		- 뷰를 물리화 한다면, 부서별 총 급여가 자주 필요한 경우에 매우 유용함
		- 이는 여러 튜플을 찾고, 그 금액을 더하는 작업을 생략하여 <font color="#00b0f0">성능을 향상</font>시키는데 중요
	- Meterialized view 유지관리
		- 뷰를 기존 데이터와 최신 상태로 유지하는 것을 <font color="#00b0f0">유지관리</font>라고 함
			- 뷰는 업데이트마다 재계산을 통해 유지할 수 있음
			- 더 나은 옵션은 <font color="#00b0f0">점진적 뷰 유지관리</font>의 사용
				- <u>데이터베이스 관계의 변경 사항을 사용하여 재료화된 뷰의 변경 사항을 계산하고 업데이트</u>
		- 뷰 유지관리는 
			- 뷰 정의에 포함된 각 관계의 삽입, 삭제 및 업데이트에 대한 트리거를 수동으로 정의하거나 
			- 데이터베이스 관계가 업데이트 될 때 뷰를 업데이트하기 위해 수동으로 작성된 코드를 사용해 수행가능
		- 현대 데이터베이스 시스템은 점진적 뷰 유지관리를 위한 직접적인 지원을 제공
			- 뷰 유지관리를 위해 데이터베이스 시스템 프로그래머는 더이상 트리거를 정의할 필요 x
			- 대신, 한번 뷰가 재료화되면 데이터베이스 시스템은 뷰의 내용을 계산하고 기본 데이터가 변경될 때 마다 내용을 점진적으로 업데이트
		- 대부분의 데이터베이스 시스템은 <font color="#00b0f0">즉각적인 뷰 유지관리</font>를 수행
			- 점진적 뷰 유지관리는 업데이트가 발생하는 즉시 업데이트 트랜잭션의 일부로 수행
			- 일부 데이터베이스 시스템은 뷰 유지관리를 나중에 연기하는 <font color="#00b0f0">지연된 뷰 유지관리</font>도 지원
		- 점진적 뷰 유지관리
			- 관계나 표현식에 대한 변경 사항 (삽입 및 삭제)는 그 **차분**이라고 불린다
			- 튜플의 업데이트는 <u>튜플의 삭제 후 업데이트된 튜플을 삽입</u>하는 것으로 대체
			- Aggregation operation에서  sum = 0일때는 불가능
	- Materialized view 선택
		- <font color="#00b0f0">Materialized view 선택</font> : 어떤 뷰의 집합이 최선?
		- <font color="#00b0f0">인덱스 선택</font> : 어떤 인덱스를 생성하는것이 최선?
		- 뷰 선택과 인덱스 선택은 주로 시스템의 **워크로드**(쿼리 및 업데이트)에 기반
			- 목표 : 워크로드를 실행하는 데 걸리는 시간을 최소화 하되, 일부 중요한 쿼리/업데이트에 대한 공간 및 시간 제약 조건을 고려
			- 데이터베이스 튜닝의 한 단계로써 수행
		- 상용 데이터베이스 시스템은 데이터베이스 관리자가 어떤 인덱스와 뷰를 생성할지 선택하는데 도움을 주는 도구를 제공 → 튜닝 어시스턴트 or 위저드
