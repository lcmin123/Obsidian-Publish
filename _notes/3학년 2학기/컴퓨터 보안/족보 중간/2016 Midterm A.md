### 1. 암호알고리즘에 대한 설명 중 틀린 것은?

_a. 현대의 암호는 크게 공개키와 대칭키 방식으로 나눌 수 있다_
O. [[공개키]] [[대칭키]]
_b. KDC는 공개키 배포 및 관리를 위해 사용된다_
범위 아님
_c. block cipher 는 암호문의 무결성을 위해 사용된다_
X. [[블럭 싸이퍼]]는 평문을 암호화, 복호화하는데 쓰이며, 데이터의 [[기밀성]]을 유지하기 위해 사용된다. 암호문의 [[무결성]]을 위해 사용되는 것은 [[해쉬]]이다
_d. 공개키 방식은 대칭키의 키 배포 문제를 극복하기 위해 개발되었다_
O. [[대칭키]]는 암호화 키와 복호화 키가 같으므로 인터넷에서 사용할 수 없는 한계를 가졌고, 그를 극복하기 위해 [[공개키]]가 등장했다
_e. 경우에 따라서 hash 를 암,복호화 알고리즘으로 사용하기도 한다_
X. [[해쉬]]는 암호화는 쉽지만 복호화는 어려운 특성을 가졌기에 암,복호화 알고리즘으로 사용할 수 없고, [[MAC]]에서 해쉬된 h(M)을 부착함으로써 암호문의 [[무결성]]을 증명하는데 사용된다.

### 2. 대칭키 암호 기법의 설명 중 잘못 된 것은?

_a. 일반적으로 공개키 보다 속도가 빠름_
O. [[대칭키]]는 [[공개키]]보다 연산 속도가 빠르다
_b. 암,복호화에 항상 동일 키 값을 사용해야만 한다_
O. [[대칭키]]
_c. 기밀성과 무결성을 제공한다_
X. [[대칭키]]는 암호화를 통해 [[기밀성]]을 제공하지만, 암호문의 [[무결성]]은 제공할 수 없다. [[무결성]]을 제공하는 것은 [[해쉬]]이다
_d. 전자서명에 서명을 위해 사용된다_
X.
_e. diffie-hellman으로 일회성 대칭키를 생성할 수 있다_
X. [[El Gammal]] 기법으로는 공개키 생성

### 3. modular operation 성질 중 틀린 것은?

_(a) [(a mod n)*(b mod n)] mod n = (a*b) mod n_
O. [[모듈러 연산]]의 곱셈 규칙
_(b) [(w*x)*y] mod n = [w*(x*y)] mod n_
O. [[모듈러 연산]]의 결합 법칙
_(c) a=b mod n ≠ a mod n = b mod n_
X. [[모듈러 연산]]
_(d) if a,n 이 relative prime이고 (a*b)=(a*c) mod n 이면, 항상 b=c mod n 이다_
O. [[모듈러 연산]]의 취소 법칙

### 4.security의 설명 중 틀린 것은?

_(a) confidentiality란 수신자가 송신자의 신원인증을 의미한다_
X. [[기밀성]]은 허가된 사용자만이 데이터의 내용을 알 수 있음을 의미하고, 수신자가 송신자의 신원인증을 의미하는 것은 [[인증]]이다
_(b) Message integrity란 메시지가 변조되지 않았음을 의미한다_
O. [[무결성]]
_(c) Authentication 란 송신자와 수신자만이 메시지를 읽을 수 있음을 의미한다_
X. [[인증]]은 수신자가 송신자의 신원을 알 수 있음을 의미하고, 송신자와 수신자만이 메시지를 읽을 수 있음을 의미하는것은 [[기밀성]]
_(d) privacy를 위해 메시지의 암,복호화를 한다_
O. 

### 5.Public key 방식에 대한 설명 중 잘못된 것은?

_(a) 일반적으로 대칭키 방식보다 비용이 많이 든다._
O. [[공개키]]는 [[대칭키]]보다 연산 비용이 크다
_(b) 사용자는 공개키, 비밀키 한 쌍을 갖는다_
O. [[공개키]]
_(c) 사용자는 갖고 있는 모든 키를 공개한다_
X. 사용자는 자신의 공개키만을 공개하고, 비밀키는 공개하지 않는다
_(d) 송신자와 사용자의 비밀키는 대칭이다_
X. [[공개키]]는 공개키와 비밀키가 다른 비대칭이다
_(e) AES는 대표적인 public key 방식이다_
X. AES는 [[대칭키]]의 [[블럭 싸이퍼]] 암호화 방식이다

### 6. Hash function 에 대한 설명 중 잘못된 것은?

_(a) hash function 은 역함수가 존재하여야 한다_
X. [[해쉬]]는 암호화가 쉬우나, 복호화는 어렵다
_(b) digital signature와 결합하여 message integrity를 제공한다_
O. [[MAC]]를 통해 평문의 뒤에 [[해쉬]]된 평문 h(M)을 부착하여, 그들을 송신자의 비밀키로 암호화 한뒤 평문에 첨부하여 그들을 수신자의 공개키로 암호화 한것이 [[전자 서명]] 기법이다
_(c) 입력값이 다르면 출력값이 달라야 한다_
O. [[해쉬]]의 특징
_(d) 대표적인 방식으로 SHA1이 있다_
O. [[해쉬]]는 MD와 SHA, HS 등의 방식이 있다
_(e) 입력의 길이에 따라 출력값의 길이가 다소 차이가 있다_
X. [[해쉬]]는 입력의 길이에 관계 없이 동일한 길이의 출력을 가진다

### 7. 평문 M을 여러 블록 b1, b2, …, bn 으로 나누어 block cipher algorithm E와 ECB 모드로 암호화, 복호화 하려고 한다. 다음중 틀린 것은?

_(a) 만일 b1=b2이면, 항상 E(b1)=E(b2)이다_
O. [[3학년 2학기/컴퓨터 보안/블럭 오퍼레이션 모드]]의 ECB는 동일한 입력에 대해 동일한 출력을 가진다
_(b) Quad-core 같은 멀티프로세서 시스템에 유용하다_
O. [[3학년 2학기/컴퓨터 보안/블럭 오퍼레이션 모드]]의 ECB는 병렬 처리에 용이한 특징을 가진다
_(c) 만일 b2를 암호화하는 과정에서 error 가 발생하면 b2이후 블록을 다시 처리해야 한다._
X. [[3학년 2학기/컴퓨터 보안/블럭 오퍼레이션 모드]]의 ECB는 각 블럭의 처리가 독립적이므로 Error Propagation이 발생하지 않는다
_(d) OFB방식에 비해서 항상 속도가 빠르다_
O. [[3학년 2학기/컴퓨터 보안/블럭 오퍼레이션 모드]]의 OFB 방식은 CFB 방식에 비해서 빠르나, 제일 간단한 모드인 ECB방식에 비해서는 느리다

### 8. Digital signature 에 대한 설명 중 틀린 것은?

_(a) 주로 public key cryptography상에서 쓰이며, symmetric cryptography에선 불가능하다._
O.
_(b) sign 은 보내는 사람의 private key를 이용한다._
O. 서명은 송신자의 비밀키를 이용하며, 그를 통해 [[인증]]의 Sender Authentication을 제공한다
_(c) 검증은 제 3의 기관(예,CA)에서 한다._
X. 검증은 수신자가 서명을 송신자의 공개키로 복호화하여, 평문의 [[무결성]]과 [[인증]]을 검증한다
_(d) 검증은 보낸 쪽의 public key를 이용한다._
O. 송신자의 비밀키로 암호화된 서명을 송신자의 공개키로 복호화하여 검증한다
_(e) hash 함수의 성질을 이용한다_
O. 평문 뒤에 [[해쉬]]함수로 평문을 암호화한 h(M)을 부착하여 [[MAC]]를 생성하고, 그를 송신자의 비밀키로 암호화 한것이 서명이다

### 9. 좋은 digital signature의 조건이 아닌 것은?

_(a) 타인이 같은 서명을 할 수 없다._
O. 오직 송신자가 자신의 비밀키로 서명함으로써 [[인증]]의 Sender Authentication이 지켜진다
_(b) 서명을 다른 문서에 옮겨 재사용이 쉬워야 한다._
X. 서명은 평문을 [[해쉬]]화 한것을 평문과 함께 보내는 것이므로, 다른 문서에는 다른 서명이 들어가야 한다
_(c) 서명자가 자신의 서명을 부인할 수 없어야 한다._
O. 서명자는 서명자의 비밀키로 서명했기에, 자신의 서명을 부인할 수 없다
_(d) 서명자가 의도적으로 문서에 서명했다는 것을 누구나 쉽게 확인할 수 없어야 한다_
X. 서명은 서명자의 공개키로 열리므로, 서명자가 의도적으로 문서에 서명했다는 것을 누구나 쉽게 확인할 수 있어야 [[인증]]의 Sender Authentication이 지켜진다

### 11. RSA에 대한 설명 중 맞는 것은?

_a. 공개키는 암호화, 비밀키는 복호화에만 사용_
X. [[RSA]]의 공개키 e,n은 암호화와 복호화에 모두 사용되고, 비밀키 d는 복호화에만 사용된다
_b. 송수신자는 같은 공개키를 나누어 갖고 있어야 한다_
X. [[RSA]], 즉 [[공개키]] 암호화 방식에서 송신자가 수신자에게 메시지를 보낼 때, 수신자의 공개 키를 사용하여 메시지를 암호화하고, 수신자는 자신의 개인 키를 사용하여 해당 암호문을 복호화하므로 
송수신자가 같은 공개키를 나누어 가질 필요가 없다
같은 공개키를 나누어 가지는 것은 [[대칭키]] 방식이다
_c. 공개키로 상대방의 비밀키를 계산할 수 있어야 한다_
X. 
_d. 비밀키는 서명에 사용할 수 있다_
O.

